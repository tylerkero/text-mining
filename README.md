# text-mining

Please read the [instructions](instructions.md).

# Reflection


## 1.
Project Overview
The data source that I utilized was the IMDB movie reviews data. I used the cinamgaoer package to access this data. The data that was gathered for each movie review contained the content of the review, the author of the review or the reviewer, how many upvotes recieved for the review, number of downvotes recieved for the review, and the rating that was given by the reviewer for the movie. I thought that each of these data groups could prove useful to an analysis. In doing so, I chose to characterize the word frequencies of the reviews to provide the user with the most common words used to describe the movie they are considering. Secondly, I used computing summary statistics to make a list of all ratings given to the inputted movie. Thirdly, I learned how to use the matlibpy package in order to create a histogram that displays the ratings from the list of the previous function. This gives a more visual approach to understand overall view of the movie. Next, I used computing summary statistics to see what percent of each review is upvotes. This gives the user an understanding about how the community thinks about the review's content. Finally, I used natural language processing to give a polarity analysis of each review along with the review allowing the user to quickly see if the review they are reading is mostly positive, negative, or neutral. 

## 2.
In order to implement the data for each function. I had to gather each movie review from the Cinemagoer package. By searching for reviews by movieID, what is returned is a large dictionary of data containing content of reviews, author, and many more as I listed in the first paragraph. My first step for each of my functions was to use a for loop to unpack each of the data to obtian what I needed. For example, when specfiically doing analysis of the content of the review, I would obtain the author of the review to use a key in a new dictionary and the content of the review to use as a value in the dictionary. For the characterizing by word frequencies portion of the assignment, I used almost every data type. For example, I used a list to filter out stopwords, I used a tuple to allow the content for each review to be hashable and then to be analyzed word by word, I used integers in counting the frequencies of the words, and finally, I used a dictionary to store each unique word as a key and the amount of times used (frequency) as values. In this function, I used the most data types that worked together, but for all my other functions I took an approach similar to how I've stated so that I can return easily readable outputs.

One design choice that I made was in my creation of my ratings function. This function is meant to display the ratings of each movie. I decided to not include and None type ratings in my analysis since, although this is truly data, it would not prove useful in any analysis that I was hoping to create. Instead of returning a dictionary with the author name and rating as I had planned, I returned just a list of the ratings given by all the authors, minus the None type ratings. From this, I was able to make a second function that took these ratings a visualized them into a histogram. I felt like this would be the best option to display rating data for movies because it is easily readable and in the visualization, the data is very condensed, allowing the user to take in more opinions at once than if they had to look at a list of reviews.

## 3.
I was very pleased with my results. My first function is meant to return each unique word used in all reviews and how many times it was used. From running this function for the movie National Lampoon's Animal House, I am given a list of words most used in the review of the movie. From this I am able to easily learn information about the film. For example, I was able to see that in the provided reviews,the word "comedy" was used 20 times, the word "college" was used 20 times, and the word "classic" was used 13 times. This tells me that many people find this movie very funny, that the setting takes place at college, and that many consider the movie to be a classic. This information helps display to me the important parts of the reviews for each movie and an overall opinion by all reviewers. 

My second and third functions worth together. These first of the two takes in movie reviews and releases a list of ratings given to that movie. The latter takes this list and turns it into a histogram. The output of the first or ratings funcition is this : 
>This is the list of ratings given to the movie by reviewers [10, 10, 7, 9, 8, 10, 10, 7, 8, 10, 8, 7, 9, 10, 10, 7, 10, 8, 8, 7, 10, 10, 10, 9].

With this, the second funciton creates a graph as shown here: 

![3](images/animalhouseresults.png)

This function brings all of the ratings data into an easily viewable graph, with the x-axis marking the ratings and the y-axis marking the amount of people who gave this rating. By putting this information into a graph, we can easily visualize rating patterns of reviewers.

Next, my fourth function returns a dicitonary of authors and the what percent of non-reviewers believe believe that a given review is good. This result is calculated by taking total upvotes divided by total votes on a review. For the movie Good Will Hunting the results are as shows: 
>This is a list of the reviewers and what percent of people believed the review was helpful: {'ur0060242': '92%', 'ur0181684': '84%', 'ur20552756': '82%', 'ur2483625': '74%', 'ur20047343': '84%', 'ur0565303': '80%', 'ur0239428': '67%', 'ur4597649': '71%', 'ur0278527': '70%', 'ur61197531': '67%', 'ur0276006': '73%', 'ur8837042': '86%', 'ur2707735': '73%', 'ur57699719': '64%', 'ur25775215': '100%', 'ur64212521': '100%', 'ur26820801': '100%', 'ur2898520': '69%', 'ur56005872': '100%', 'ur62442180': '100%', 'ur120431365': '100%', 'ur0200815': '71%', 'ur20250079': '100%'}

This allows the user to see which reviews are the most trustworthy and then therefore allow them to make a better decision on what opinion to trust. For example, I am much more likely to trust ur0060242's review with 92% upvotes compared to ur61197531's with only 67% updvotes.

 Finally, my last funciton returns a dictionary with the review as a key and the polarity sentiment analysis of each review given of the movie as the value. This allows the user to see if the tone of the content of the review is positive, negative, or netural language.
An example is shown for the movie Good Will Hunting : 

>"For the longest period of time I never understood the title of this film. Was it about someone on some Diogenes style quest? Or was was it about someone who scowers thrift stores? Well, it has nothing to do with good will or Goodwill, it's about a young man called Will Hunting. He's a(somewhat unrealistic)genius who can solve math problems that baffle the world's greatest minds and knows twice as much on any subject covered in a Harvard class...yet he works as a janitor. A professor at MIT stumbles across and sets him up with 
a therapist, who tries to counsel Will while drilling to the core of his problems.The film might be centered around Matt Damon, who gives a deep performance, but Robin Williams claims every scene he's in and is the most memorable thing from this film. As you probably know, the picture also features Ben Affleck in a limited role, through which he still makes his talent evident. But while Damon, Affleck and William's may have been good choices Minnie Driver certainly wasn't. Who thought of her for the role or what they saw I'll never know.The backstory behind the script is so well known that I won't bother going over it; all I will add is that Affleck and Damon didn't do to bad a job for a first time and recieved a merited Oscar for it.Good Will Hunting is a thought provoking film and that's why so many enjoy it. It's a film that actually tried to be more than cheap entertainment and it succeeded.": {'neg': 0.023, 'neu': 0.819, 'pos': 0.158, 'compound': 0.9896}

We can see that the review displayed uses very little negative language, much neutral language, and some positive language. These results can help a user understand the an overall trend of reviews for a movie. 

## 4.
The process began slow in trying to understand how to call the data I wanted, but once I figured that out it went really great! It was very easy to come up with ideas and I was able to include almost all the data given from Cinemagoer movie reviews package in a function. In the end, I decided against using any text-similarity or clustering. I believe the other functions I created are more useful for a user to undestand a movie through the reviews provided. A text-similarity function would just display which reviews are similar and my goal for the project was to allow a user to learn about the movie itself, from the reviews. I thought that I was able to return useful results to my user and provide an interactive way to obtain the data. I believe I could improve on the visualization of my function's output. For example, I attempted to use pprint for my final function regarding the nltk polarity output but instead of making the output easier to read, it created huge spacing issues. In the end, I decided to go with printing the funciton in orginal dictionary output which makes the data very compact and not easy to read. In support of this, with a little more knowledge of different packages outside of pprint, I believe I could make my results look much cleaner. Also, I know I have a long ways to go in creating the most efficient code. I know that my code can be made more efficient I just don't believe I have the knowledge right now to make it more efficient that it is already, with having it still work at the same time. I wish that at the beginning of the project I knew how to best use each data type to create results, but through trial and error from this project, I learned much more on how these types work together. I really wish that an index out of bounds error would not show up when I ask for a movie name. This can be controlled by using movieIDs, but I wished to make the program more interactive to a user so that they wouldn't have to do the process of looking up the ID, even it if it means them having to run the program a few times. Overall, I thought this project was awesome! I came into this class very confused on how gathering data from the internet works and I feel like by creating my own text-mining program, I am much more confident in my coding ability. This was super fun and I'm really glad with the outcome.